1.1 创建 Mercari 工具的后端 API 基础结构
目标 (Goal): 创建一个基础的后端 API 端点 (GET /api/mercari/shops-overview)。这个端点是仪表盘页面的数据来源。

关键任务 (Key Task): 为了让前端可以并行开发，这个故事要求后端仅返回一个硬编码的模拟（Mock）数据列表。真实的 Mercari API 调用将在后续的故事中实现。这能确保我们首先建立起前后端之间的“通信契约”。

开发者说明 (Dev Notes): 我已经在故事文件的 Dev Notes 部分，从架构文档中提取了所有相关的技术上下文 ，包括文件应存放的位置 (

/src/api/mercari/) 和 API 的响应格式，以确保开发代理可以准确地执行任务。

1.2 创建 Mercari 工具的前端仪表盘页面
目标 (Goal): 创建一个 React 前端页面，作为多店铺管理的仪表盘。它将调用我们在故事 1.1 中创建的后端 API，并展示所有已配置的 Mercari 店铺列表。

关键任务 (Key Task):

创建一个新的页面组件，并为其配置路由 /mercari-tool。

页面加载时，调用后端的 GET /api/mercari/shops-overview 接口。

将返回的店铺列表（目前是模拟数据）清晰地展示出来，包括店铺名称和未处理订单数。

实现列表项的点击功能，点击后能跳转到对应的店铺详情页路由（例如 /mercari-tool/shop_id_123）。

处理加载中和加载失败的界面状态。

开发者说明 (Dev Notes): 故事文件中已包含了所有必要的上下文，包括要调用的 API 端点、期望的 UI 行为、文件存放位置 (/src/pages/mercari/) 以及导航逻辑。

1.3 实现后端获取 Mercari 店铺真实订单数量的功能。
目标 (Goal):
修改我们在故事 1.1 中创建的后端服务，使其不再返回写死的模拟数据，而是通过调用真实的 Mercari Shops API，获取每个店铺准确的“未处理”订单数量。

关键任务 (Key Task):

从数据库中查询所有已配置的 Mercari 店铺及其加密的 API 密钥。

安全地解密每个店铺的 API 密钥。

使用解密后的密钥，为每个店铺分别调用 Mercari Shops 的 GET /orders 端点。

汇总每个店铺的订单数量，并按照之前定义好的数据格式返回给前端。

实现完善的错误处理，例如当某个店铺的 API 密钥失效时，不能影响其他店铺的数据获取。

开发者说明 (Dev Notes):
故事文件中特别强调了此任务的安全要求，即 API 密钥的加密与解密处理流程。同时，也包含了关于如何处理对多个外部 API 循环调用的错误处理策略。

1.4 创建后端 API 以获取单个店铺的详细订单列表。
目标 (Goal):
创建一个新的后端 API 端点。当提供一个店铺 ID 时，这个端点能够返回该特定店铺所有“未处理”订单的完整详细列表。

关键任务 (Key Task):

在 Node.js 后端创建一个新的路由，例如 GET /api/mercari/shops/:shopId/orders。

后端服务接收到请求后，根据传入的 shopId 从数据库中查询对应的店铺信息和 API 密钥。

使用该店铺的密钥，调用 Mercari Shops API，获取所有未发货订单的 完整数据（而不仅仅是数量）。

将从 Mercari 获取的原始订单数据列表，以 JSON 格式直接返回给前端。

处理当 shopId 无效或找不到时的情况，返回 404 错误。

开发者说明 (Dev Notes):
这个故事将复用故事 1.3 中建立的安全认证和 API 调用逻辑。它创建的数据接口，是下一个前端故事（店铺详情页）能够成功实现的基础。

1.5 创建店铺详情页以展示详细订单列表。
目标 (Goal):
创建一个新的前端页面。当用户在仪表盘点击某个店铺时，会跳转到这个页面，并清晰地展示出该店铺所有“未处理”订单的详细列表。

关键任务 (Key Task):

创建一个新的 React 页面组件，并将其关联到动态路由 /mercari-tool/:shopId。

页面加载时，从 URL 中获取 shopId。

调用我们在故事 1.4 中创建的后端 API (GET /api/mercari/shops/:shopId/orders)。

将返回的订单数据，以表格或列表的形式清晰地展示出来，至少包含订单号、客户名、下单日期和商品信息。

在页面上添加“生成 Click Post CSV”和“打印面单”的占位按钮。在本次故事中，这些按钮应为禁用状态，其功能将在后续故事中实现。

开发者说明 (Dev Notes):
这个故事将故事 1.2（前端仪表盘）和故事 1.4（后端详情 API）连接起来，形成了一个完整的“查看数据”的用户流程。它为我们接下来实现核心的文件生成功能铺平了道路。

1.6 实现生成并下载 Click Post CSV 文件的功能。
目标 (Goal):
在店铺详情页上，激活“生成 Click Post CSV”按钮。用户能够勾选所需处理的订单，点击按钮后，系统能够生成一份严格符合日本邮政 Click Post 格式要求的 CSV 文件，并提供给用户下载。

关键任务 (Key Task):

前端: 在订单列表的每一行前增加复选框（Checkbox），并提供一个“全选”功能。当至少有一个订单被选中时，激活“生成 Click Post CSV”按钮。

前端: 当用户点击按钮时，将选中的订单 ID 列表，连同店铺 ID 一起，通过 POST /api/mercari/process-orders API 发送给后端。

后端: 接收到请求后，根据订单 ID 列表从 Mercari 获取这些订单的完整数据。

后端: (核心) 将获取到的订单数据，严格按照您拥有的“Click Post CSV 规范”，进行数据转换和格式化，并生成 CSV 文件。

后端: 将生成的文件提供一个安全的下载链接，返回给前端。

前端: 触发浏览器的文件下载功能。

开发者说明 (Dev Notes):
这是整个 MVP（最小可行产品）中最重要的一个故事。我已在故事文件中明确指出，开发人员必须依据您提供的“Click Post CSV 规范文档”来进行后端的数据映射，确保生成的 CSV 文件 100%兼容。

1.7 实现打印自定义发货面单的功能。
目标 (Goal):
在店铺详情页上，激活“打印面单”按钮。用户能够勾选所需处理的订单，点击按钮后，系统能够打开一个包含所有选定订单、格式清晰的发货面单的新页面，以便用户直接从浏览器打印，该页面 A5 尺寸。

关键任务 (Key Task):

前端: 激活“打印面单”按钮，并为其添加点击事件处理。

前端: 当用户点击按钮时，将选中的订单 ID 列表，连同店铺 ID 一起，通过 POST /api/mercari/process-orders API 发送给后端（但这次使用一个新的 action 标识，例如 generate_slips）。

后端: 接收到请求后，根据订单 ID 列表从 Mercari 获取这些订单的完整数据。

后端: (核心) 将订单数据填入一个预设的 HTML 模板中，生成一个对打印机友好的网页。该网页将为每个订单生成一个独立的面单部分。

后端: 将生成网页的 URL 返回给前端。

前端: 在新的浏览器标签页中打开这个 URL，用户便可看到所有面单并进行打印。

开发者说明 (Dev Notes):
故事文件中详细说明了面单上必须包含的所有字段（如店铺 Logo, 商品管理编号, 客户留言等），这些都是基于我们之前的架构讨论。开发者需要创建一个美观且打印清晰的 HTML 和 CSS 模板。
